---
description: Visual process map for PLAN mode (Code Implementation)
globs: plan-mode-map.mdc
alwaysApply: false
---

# PLAN MODE: TASK PLANNING PROCESS MAP

üö® MANDATORY: DATE/TIME STAMPS MUST USE sys8 MCP üö®
When updating ANY timestamp fields in planning documents:
- MUST call sys8 MCP get_current_datetime FIRST
- MUST use the datetime value returned by sys8 MCP
- MUST NOT use JavaScript Date(), hardcoded dates, or any other method
- This applies to "Last Updated", "Date", and all other date/time fields

> **TL;DR:** This visual map guides the PLAN mode process, focusing on creating detailed implementation plans based on the complexity level determined during initialization, with mandatory technology validation before implementation.

## üß≠ PLAN MODE PROCESS FLOW

```mermaid
graph TD
    Start["START PLANNING"] --> MCPGate["‚õî MCP SERVERS<br>CONTEXT GATE"]
    
    %% MCP Server Queries
    MCPGate --> QuerySys8["Query sys8 MCP<br>get_current_datetime<br>get_os_version"]
    QuerySys8 --> QueryContext7["Query context7 MCP<br>resolve-library-id<br>get-library-docs"]
    QueryContext7 --> IncludeContext["Include MCP Results<br>in Request Context"]
    
    IncludeContext --> ReadTasks["Read tasks.md<br>Core/task-tracking.md"]
    
    %% Complexity Level Determination
    ReadTasks --> CheckLevel{"Determine<br>Complexity Level"}
    CheckLevel -->|"Level 2"| Level2["LEVEL 2 PLANNING<br>Level2/enhancement-planning.md"]
    CheckLevel -->|"Level 3"| Level3["LEVEL 3 PLANNING<br>Level3/feature-planning.md"]
    CheckLevel -->|"Level 4"| Level4["LEVEL 4 PLANNING<br>Level4/system-planning.md"]
    
    %% Level 2 Planning
    Level2 --> L2Review["Review Code<br>Structure"]
    L2Review --> L2Document["Document<br>Planned Changes"]
    L2Document --> L2Challenges["Identify<br>Challenges"]
    L2Challenges --> L2Checklist["Create Task<br>Checklist"]
    L2Checklist --> L2Update["Update tasks.md<br>with Plan"]
    L2Update --> L2Tech["TECHNOLOGY<br>VALIDATION"]
    L2Tech --> L2Verify["Verify Plan<br>Completeness"]
    
    %% Level 3 Planning
    Level3 --> L3Review["Review Codebase<br>Structure"]
    L3Review --> L3Requirements["Document Detailed<br>Requirements"]
    L3Requirements --> L3Components["Identify Affected<br>Components"]
    L3Components --> L3Plan["Create Comprehensive<br>Implementation Plan"]
    L3Plan --> L3Challenges["Document Challenges<br>& Solutions"]
    L3Challenges --> L3Update["Update tasks.md<br>with Plan"]
    L3Update --> L3Tech["TECHNOLOGY<br>VALIDATION"]
    L3Tech --> L3Flag["Flag Components<br>Requiring Creative"]
    L3Flag --> L3Verify["Verify Plan<br>Completeness"]
    
    %% Level 4 Planning
    Level4 --> L4Analysis["Codebase Structure<br>Analysis"]
    L4Analysis --> L4Requirements["Document Comprehensive<br>Requirements"]
    L4Requirements --> L4Diagrams["Create Architectural<br>Diagrams"]
    L4Diagrams --> L4Subsystems["Identify Affected<br>Subsystems"]
    L4Subsystems --> L4Dependencies["Document Dependencies<br>& Integration Points"]
    L4Dependencies --> L4Plan["Create Phased<br>Implementation Plan"]
    L4Plan --> L4Update["Update tasks.md<br>with Plan"]
    L4Update --> L4Tech["TECHNOLOGY<br>VALIDATION"]
    L4Tech --> L4Flag["Flag Components<br>Requiring Creative"]
    L4Flag --> L4Verify["Verify Plan<br>Completeness"]
    
    %% Technology Validation Gate - NEW
    L2Tech & L3Tech & L4Tech --> TechGate["‚õî TECHNOLOGY<br>VALIDATION GATE"]
    TechGate --> TechSelection["Document Technology<br>Stack Selection"]
    TechSelection --> TechHelloWorld["Create Hello World<br>Proof of Concept"]
    TechHelloWorld --> TechDependencies["Verify Required<br>Dependencies"]
    TechDependencies --> TechConfig["Validate Build<br>Configuration"]
    TechConfig --> TechBuild["Complete Test<br>Build"]
    TechBuild --> TechVerify["‚õî TECHNOLOGY<br>CHECKPOINT"]
    
    %% Verification & Completion
    L2Verify & L3Verify & L4Verify & TechVerify --> CheckCreative{"Creative<br>Phases<br>Required?"}
    
    %% Mode Transition
    CheckCreative -->|"Yes"| RecCreative["NEXT MODE:<br>CREATIVE MODE"]
    CheckCreative -->|"No"| RecBuild["NEXT MODE:<br>BUILD MODE"]
    
    %% Style for Technology Gate
    style MCPGate fill:#ff5555,stroke:#dd3333,color:white,stroke-width:3px
    style QuerySys8 fill:#4da6ff,stroke:#0066cc,color:white
    style QueryContext7 fill:#4da6ff,stroke:#0066cc,color:white
    style IncludeContext fill:#4da6ff,stroke:#0066cc,color:white
    style TechGate fill:#ff5555,stroke:#dd3333,color:white,stroke-width:3px
    style TechVerify fill:#ff5555,stroke:#dd3333,color:white,stroke-width:3px
    style TechSelection fill:#4da6ff,stroke:#0066cc,color:white
    style TechHelloWorld fill:#4da6ff,stroke:#0066cc,color:white
    style TechDependencies fill:#4da6ff,stroke:#0066cc,color:white
    style TechConfig fill:#4da6ff,stroke:#0066cc,color:white
    style TechBuild fill:#4da6ff,stroke:#0066cc,color:white
```

## üìã LEVEL-SPECIFIC PLANNING APPROACHES

```mermaid
graph TD
    subgraph "Level 2: Enhancement"
        L2A["Basic Requirements<br>Analysis"]
        L2B["Simple Component<br>Identification"]
        L2C["Linear Implementation<br>Plan"]
        L2D["Basic Checklist<br>Creation"]
    end
    
    subgraph "Level 3: Feature"
        L3A["Detailed Requirements<br>Analysis"]
        L3B["Component Mapping<br>with Dependencies"]
        L3C["Multi-Phase<br>Implementation Plan"]
        L3D["Comprehensive<br>Checklist"]
        L3E["Creative Phase<br>Identification"]
    end
    
    subgraph "Level 4: System"
        L4A["Architectural<br>Requirements Analysis"]
        L4B["System Component<br>Mapping"]
        L4C["Subsystem<br>Integration Plan"]
        L4D["Phased Implementation<br>Strategy"]
        L4E["Risk Assessment<br>& Mitigation"]
        L4F["Multiple Creative<br>Phase Requirements"]
    end
    
    L2A --> L2B --> L2C --> L2D
    L3A --> L3B --> L3C --> L3D --> L3E
    L4A --> L4B --> L4C --> L4D --> L4E --> L4F
```

## üîß TECHNOLOGY VALIDATION WORKFLOW

```mermaid
graph TD
    Start["Technology<br>Validation Start"] --> Select["Technology<br>Stack Selection"]
    Select --> Document["Document Chosen<br>Technologies"]
    Document --> POC["Create Minimal<br>Proof of Concept"]
    POC --> Build["Verify Build<br>Process Works"]
    Build --> Dependencies["Validate All<br>Dependencies"]
    Dependencies --> Config["Confirm Configuration<br>Files Are Correct"]
    Config --> Test["Complete Test<br>Build/Run"]
    Test --> Success{"All Checks<br>Pass?"}
    
    Success -->|"Yes"| Ready["Ready for<br>Implementation"]
    Success -->|"No"| Fix["Fix Technology<br>Issues"]
    Fix --> Document
    
    style Start fill:#4da6ff,stroke:#0066cc,color:white
    style POC fill:#4da6ff,stroke:#0066cc,color:white
    style Success fill:#ff5555,stroke:#dd3333,color:white
    style Fix fill:#ff5555,stroke:#dd3333,color:white
    style Ready fill:#10b981,stroke:#059669,color:white
```

## üîå MANDATORY MCP SERVER CONTEXT INTEGRATION

**CRITICAL REQUIREMENT:** Before any planning work begins, the agent MUST query MCP servers and include their results in the request context.

### Step 1: Query sys8 MCP Server
**MANDATORY:** Query sys8 MCP server for system information:
- `get_current_datetime` - Get current date/time for planning timelines
- `get_os_version` - Get OS/platform information for platform-specific planning

### Step 2: Query context7 MCP Server
**MANDATORY:** Query context7 MCP server for library documentation:
- `resolve-library-id` - Resolve library names mentioned in task to Context7 library IDs
- `get-library-docs` - Get up-to-date documentation for libraries/frameworks used in planning

### Step 3: Include MCP Results in Context
**MANDATORY:** Include all MCP query results in the request context:
- System date/time information from sys8
- Platform/OS information from sys8
- Library documentation from context7
- Library IDs and API references from context7

### MCP Context Integration Checklist
```
‚úì MCP CONTEXT INTEGRATION CHECKLIST
- sys8 get_current_datetime queried? [YES/NO]
- sys8 get_os_version queried? [YES/NO]
- context7 resolve-library-id called for all libraries? [YES/NO]
- context7 get-library-docs called for relevant libraries? [YES/NO]
- All MCP results included in request context? [YES/NO]

‚Üí If all YES: Proceed with planning
‚Üí If any NO: Complete MCP queries before proceeding
```

## üìä REQUIRED FILE STATE VERIFICATION

Before planning can begin, verify the file state:

```mermaid
graph TD
    Start["File State<br>Verification"] --> CheckTasks{"tasks.md<br>initialized?"}
    
    CheckTasks -->|"No"| ErrorTasks["ERROR:<br>Return to VAN Mode"]
    CheckTasks -->|"Yes"| CheckActive{"activeContext.md<br>exists?"}
    
    CheckActive -->|"No"| ErrorActive["ERROR:<br>Return to VAN Mode"]
    CheckActive -->|"Yes"| ReadyPlan["Ready for<br>Planning"]
```

## üìù TASKS.MD UPDATE FORMAT

During planning, update tasks.md with this structure:

```
# Task: [Task name]

## Description
[Detailed description]

## Complexity
Level: [2/3/4]
Type: [Enhancement/Feature/Complex System]

## Technology Stack
- Framework: [Selected framework]
- Build Tool: [Selected build tool]
- Language: [Selected language]
- Storage: [Selected storage mechanism]

## Technology Validation Checkpoints
- [ ] Project initialization command verified
- [ ] Required dependencies identified and installed
- [ ] Build configuration validated
- [ ] Hello world verification completed
- [ ] Test build passes successfully

## Status
- [x] Initialization complete
- [x] Planning complete
- [ ] Technology validation complete
- [ ] [Implementation steps]

## Implementation Plan
1. [Step 1]
   - [Subtask 1.1]
   - [Subtask 1.2]
2. [Step 2]
   - [Subtask 2.1]
   - [Subtask 2.2]

## Creative Phases Required
- [ ] [Component 1] Design
- [ ] [Component 2] Architecture
- [ ] [Component 3] Data Model

## Dependencies
- [Dependency 1]
- [Dependency 2]

## Challenges & Mitigations
- [Challenge 1]: [Mitigation strategy]
- [Challenge 2]: [Mitigation strategy]
```

## üìã CREATIVE PHASE IDENTIFICATION

For Level 3-4 tasks, identify components requiring creative phases:

```mermaid
graph TD
    Start["Creative Phase<br>Identification"] --> CheckComp{"Component<br>Analysis"}
    
    CheckComp --> UI["UI/UX<br>Components"]
    CheckComp --> Data["Data Model<br>Components"]
    CheckComp --> Arch["Architecture<br>Components"]
    CheckComp --> Algo["Algorithm<br>Components"]
    
    UI & Data & Arch & Algo --> Decision{"Design Decisions<br>Required?"}
    
    Decision -->|"Yes"| Flag["Flag for<br>Creative Phase"]
    Decision -->|"No"| Skip["Standard<br>Implementation"]
    
    Flag --> Document["Document in<br>tasks.md"]
```

## üìä TECHNOLOGY VALIDATION CHECKLIST

```
‚úì TECHNOLOGY VALIDATION CHECKLIST
- Technology stack clearly defined? [YES/NO]
- Project initialization command documented? [YES/NO]
- Required dependencies identified? [YES/NO]
- Minimal proof of concept created? [YES/NO]
- Hello world build/run successful? [YES/NO]
- Configuration files validated? [YES/NO]
- Test build completes successfully? [YES/NO]

‚Üí If all YES: Technology validation complete - ready for next phase
‚Üí If any NO: Resolve technology issues before proceeding
```

## üìä PLAN VERIFICATION CHECKLIST

```
‚úì PLAN VERIFICATION CHECKLIST
- Requirements clearly documented? [YES/NO]
- Technology stack validated? [YES/NO]
- Affected components identified? [YES/NO]
- Implementation steps detailed? [YES/NO]
- Dependencies documented? [YES/NO]
- Challenges & mitigations addressed? [YES/NO]
- Creative phases identified (Level 3-4)? [YES/NO/NA]
- tasks.md updated with plan? [YES/NO]

‚Üí If all YES: Planning complete - ready for next mode
‚Üí If any NO: Complete missing plan elements
```

## üîÑ MODE TRANSITION NOTIFICATION

When planning is complete, notify user with:

```
## PLANNING COMPLETE

‚úÖ Implementation plan created
‚úÖ Technology stack validated
‚úÖ tasks.md updated with plan
‚úÖ Challenges and mitigations documented
[‚úÖ Creative phases identified (for Level 3-4)]

‚Üí NEXT RECOMMENDED MODE: [CREATIVE/BUILD] MODE
```

---

## üéØ AI QUALITY RULES INTEGRATION

> **Apply these quality rules during PLAN mode for better task planning.**

### Quality Rules for PLAN Mode

| Rule | When to Apply | Quick Reference |
|------|---------------|-----------------|
| **#1 Stubbing** | Task breakdown | Break into max 50-line stubs |
| **#5 DoD** | Requirements | Create testable done criteria |
| **#6 Corner Cases** | Requirements | List boundaries before coding |
| **#7 Skeleton-First** | Architecture | Create stubs before implementation |
| **#11 Boundaries** | Scope definition | State what we DON'T do |

---

### üìã Rule #1: Stubbing / Decomposition

> **Apply at:** Task Breakdown / Component Identification

**One-liner:** Break complex tasks into stubs of max 50 lines each.

<details>
<summary>üìñ Detailed Guidance</summary>

**When to Apply:** When breaking down tasks into implementation steps.

**How to Apply:**
1. Identify the main task
2. Break into logical sub-tasks
3. Ensure each stub is <50 lines
4. Define clear input/output for each

**Example:**
```typescript
// Instead of one 200-line function:
async function processOrder(order) {
  await validateOrder(order);      // Stub 1: ~20 lines
  await calculatePricing(order);   // Stub 2: ~30 lines
  await processPayment(order);     // Stub 3: ~40 lines
  await sendConfirmation(order);   // Stub 4: ~15 lines
}
```

**Checklist:**
- [ ] Each stub < 50 lines
- [ ] Single responsibility per stub
- [ ] Clear input/output defined
- [ ] Stubs are independently testable

**Full Rule:** `Core/AI-Quality/foundation/stubbing-rule.mdc`
</details>

---

### üìã Rule #5: Definition of Done (DoD)

> **Apply at:** Requirements Documentation

**One-liner:** Create explicit DoD checklist that auto-generates test cases.

<details>
<summary>üìñ Detailed Guidance</summary>

**When to Apply:** When documenting requirements for any task.

**Template:**
```markdown
## Definition of Done: [Feature Name]

### Functional
- [ ] [Specific behavior 1]
- [ ] [Specific behavior 2]

### Edge Cases
- [ ] Null input handled
- [ ] Empty input handled
- [ ] Concurrent access handled

### Quality
- [ ] All tests pass
- [ ] Code reviewed
- [ ] Methods < 50 lines
```

**Quality Test:** Can you write a test for each DoD item?
- YES ‚Üí Good DoD item
- NO ‚Üí Rewrite to be more specific

**Full Rule:** `Core/AI-Quality/context/dod-rule.mdc`
</details>

---

### üìã Rule #6: Corner Cases

> **Apply at:** Requirements / Risk Assessment

**One-liner:** List corner cases and boundary conditions BEFORE writing tests or code.

<details>
<summary>üìñ Detailed Guidance</summary>

**Categories to Document:**

| Category | Examples |
|----------|----------|
| Input Validation | null, empty, too long, invalid type |
| Boundary Values | min, max, zero, negative |
| Concurrency | race conditions, deadlocks |
| External Deps | timeouts, failures, unavailable |
| State Transitions | invalid states, partial updates |

**Template:**
```markdown
## Corner Cases: [Feature]

### Input Validation
| Case | Input | Expected |
|------|-------|----------|
| Null | null | Error: "Required" |
| Empty | "" | Error: "Cannot be empty" |

### Concurrency
| Case | Scenario | Expected |
|------|----------|----------|
| Race | 100 simultaneous | Only 1 succeeds |
```

**Full Rule:** `Core/AI-Quality/context/corner-cases-rule.mdc`
</details>

---

### üìã Rule #7: Skeleton-First

> **Apply at:** Architecture Planning / Component Design

**One-liner:** Create architecture skeleton with empty stubs. Review structure BEFORE implementing.

<details>
<summary>üìñ Detailed Guidance</summary>

**Sequence:**
1. Define interfaces and types
2. Create classes with empty method stubs
3. Review architecture for issues
4. Only then implement one stub at a time

**Example:**
```typescript
// Step 1: Interface
interface Storage {
  addItem(id: string, data: any): Promise<Result>;
  getItem(id: string): Promise<Item>;
}

// Step 2: Skeleton
class PostgresStorage implements Storage {
  async addItem(id: string, data: any) {
    // TODO: implement
    throw new Error('Not implemented');
  }
  async getItem(id: string) {
    // TODO: implement
    throw new Error('Not implemented');
  }
}

// Step 3: Review architecture
// Step 4: Implement one at a time
```

**Full Rule:** `Core/AI-Quality/architecture/skeleton-rule.mdc`
</details>

---

### üìã Rule #11: Task Boundaries

> **Apply at:** Scope Definition / Requirements

**One-liner:** Explicitly state what is OUT OF SCOPE to prevent scope creep.

<details>
<summary>üìñ Detailed Guidance</summary>

**Template:**
```markdown
## Task: [Name]

### ‚úÖ What We DO
- Feature A
- Feature B

### ‚ùå What We DON'T Do (Out of Scope)
- Optimization (separate task)
- Caching (future enhancement)
- Migration (DBA task)
```

**Why Important:**
- Prevents AI from expanding scope
- Makes completion clear
- Saves tokens and time

**Full Rule:** `Core/AI-Quality/quality/boundaries-rule.mdc`
</details>

---

### ‚úÖ PLAN Mode Quality Checkpoint

Before transitioning from PLAN mode:

```
‚ñ° Task decomposed into stubs < 50 lines (Rule #1)?
‚ñ° Definition of Done is testable (Rule #5)?
‚ñ° Corner cases documented (Rule #6)?
‚ñ° Architecture skeleton defined (Rule #7)?
‚ñ° Boundaries clearly state exclusions (Rule #11)?

‚Üí All checked: Ready for CREATIVE/BUILD
‚Üí Missing items: Complete before transition
```