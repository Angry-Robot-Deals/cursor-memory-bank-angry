---
description: Rule #13 - Transaction Isolation - Explicit isolation levels and race condition handling
globs: technical/transaction-rule.mdc
alwaysApply: false
---

# RULE #13: TRANSACTION ISOLATION

> **Goal:** Prevent data corruption by explicitly specifying transaction isolation levels and testing for race conditions.

## ðŸŽ¯ CORE PRINCIPLE

**Always explicitly specify transaction isolation level. Never assume defaults. Test for race conditions.**

Implicit defaults cause subtle bugs. Explicit specification ensures correct behavior.

---

## ðŸ“‹ RULE SPECIFICATION

```yaml
TRANSACTION_RULE:
  requirements:
    - explicit_isolation: "SET TRANSACTION ISOLATION LEVEL"
    - race_condition_tests: "Concurrent operation tests"
    - discuss_upfront: "Mention isolation in requirements"
  levels:
    - READ_UNCOMMITTED: "Never use"
    - READ_COMMITTED: "Default, most cases"
    - REPEATABLE_READ: "Prevent non-repeatable reads"
    - SERIALIZABLE: "Critical operations only"
  mandatory_tests: "100 concurrent operations test"
```

---

## ðŸ“Š ISOLATION LEVELS REFERENCE

### Comparison Table

| Level | Dirty Read | Non-Repeatable | Phantom | Performance |
|-------|------------|----------------|---------|-------------|
| READ UNCOMMITTED | âœ“ | âœ“ | âœ“ | Fastest |
| READ COMMITTED | âœ— | âœ“ | âœ“ | Fast |
| REPEATABLE READ | âœ— | âœ— | âœ“ | Medium |
| SERIALIZABLE | âœ— | âœ— | âœ— | Slowest |

### When to Use Each

```markdown
READ COMMITTED (Default)
â”œâ”€â”€ Most CRUD operations
â”œâ”€â”€ Read-only queries
â””â”€â”€ When eventual consistency OK

REPEATABLE READ
â”œâ”€â”€ Reports that read same data twice
â”œâ”€â”€ Calculations based on multiple reads
â””â”€â”€ When consistency within transaction needed

SERIALIZABLE
â”œâ”€â”€ Financial transactions
â”œâ”€â”€ Inventory management
â”œâ”€â”€ Like/vote deduplication
â””â”€â”€ Any "check-then-insert" pattern
```

---

## âœ… HOW TO APPLY

### Step 1: Explicit Isolation in Code

```typescript
// âŒ BAD: Implicit isolation (uses database default)
async function addLike(videoId: string, ip: string) {
  return await db.transaction(async (tx) => {
    // What isolation level? Who knows!
    const existing = await tx.query(/*...*/);
    // Race condition possible!
    if (!existing) {
      await tx.query('INSERT...');
    }
  });
}

// âœ… GOOD: Explicit isolation
async function addLike(videoId: string, ip: string) {
  return await db.transaction(async (tx) => {
    // Explicit: I know what I'm doing
    await tx.query('SET TRANSACTION ISOLATION LEVEL SERIALIZABLE');
    
    const existing = await tx.query(
      'SELECT id FROM likes WHERE video_id = $1 AND ip = $2',
      [videoId, ip]
    );
    
    if (existing.rows.length > 0) {
      return { added: false };
    }
    
    await tx.query(
      'INSERT INTO likes (video_id, ip) VALUES ($1, $2)',
      [videoId, ip]
    );
    
    return { added: true };
  });
}
```

### Step 2: Add Database Constraints

```sql
-- Additional protection: unique constraint
ALTER TABLE likes 
ADD CONSTRAINT unique_like_per_ip 
UNIQUE (video_id, ip_address);
```

### Step 3: Concurrent Test

```typescript
// MANDATORY: Test with 100 concurrent operations
describe('addLike concurrency', () => {
  it('should handle 100 simultaneous likes from same IP', async () => {
    const videoId = 'test-video';
    const ipAddress = '192.168.1.1';
    
    // Fire 100 concurrent requests
    const promises = Array(100).fill(null)
      .map(() => storage.addLike(videoId, ipAddress));
    
    // Wait for all to complete
    const results = await Promise.all(promises);
    
    // Count how many actually added
    const addedCount = results.filter(r => r.added).length;
    
    // Verify: Only 1 should succeed
    expect(addedCount).toBe(1);
    
    // Verify database state
    const count = await storage.getLikeCount(videoId);
    expect(count).toBe(1);
  });

  it('should handle concurrent likes from different IPs', async () => {
    const videoId = 'test-video';
    
    // 100 different IPs
    const promises = Array(100).fill(null)
      .map((_, i) => storage.addLike(videoId, `192.168.1.${i}`));
    
    await Promise.all(promises);
    
    // All 100 should succeed
    const count = await storage.getLikeCount(videoId);
    expect(count).toBe(100);
  });
});
```

---

## ðŸ“‹ COMMON RACE CONDITION PATTERNS

### Pattern 1: Check-Then-Insert

```typescript
// âŒ RACE CONDITION: Two requests check simultaneously
// Request A: Check â†’ Not exists â†’ INSERT
// Request B: Check â†’ Not exists â†’ INSERT  (both insert!)

// âœ… SAFE: Use SERIALIZABLE or UNIQUE constraint
await tx.query('SET TRANSACTION ISOLATION LEVEL SERIALIZABLE');
// Or: INSERT ... ON CONFLICT DO NOTHING
```

### Pattern 2: Read-Modify-Write

```typescript
// âŒ RACE CONDITION: Lost update
// Request A: Read balance=100 â†’ Update to 90
// Request B: Read balance=100 â†’ Update to 80 (overwrites A!)

// âœ… SAFE: Use SELECT FOR UPDATE
const result = await tx.query(
  'SELECT balance FROM accounts WHERE id = $1 FOR UPDATE',
  [accountId]
);
```

### Pattern 3: Counter Increment

```typescript
// âŒ RACE CONDITION: Lost increments
// Request A: Read count=5 â†’ Write count=6
// Request B: Read count=5 â†’ Write count=6 (lost increment!)

// âœ… SAFE: Atomic increment
await tx.query(
  'UPDATE counters SET value = value + 1 WHERE id = $1',
  [counterId]
);
```

---

## ðŸ“Š ISOLATION DECISION GUIDE

```
OPERATION TYPE                    â†’ ISOLATION LEVEL
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Simple read                       â†’ READ COMMITTED
Multiple reads, same data         â†’ REPEATABLE READ
Check-then-insert                 â†’ SERIALIZABLE + CONSTRAINT
Financial transaction             â†’ SERIALIZABLE
Inventory update                  â†’ SERIALIZABLE + FOR UPDATE
Read-modify-write                 â†’ SELECT FOR UPDATE
Counter increment                 â†’ Atomic UPDATE
```

---

## ðŸ“‹ TRANSACTION CHECKLIST

### Before Implementation

```markdown
â–¡ Identified operations that need transactions
â–¡ Determined appropriate isolation level
â–¡ Documented isolation choice in requirements
â–¡ Planned unique constraints if needed
```

### During Implementation

```markdown
â–¡ SET TRANSACTION ISOLATION LEVEL explicit
â–¡ Added unique constraints where needed
â–¡ Used FOR UPDATE for read-modify-write
â–¡ Used atomic operations for counters
```

### Testing

```markdown
â–¡ Wrote concurrent operation test
â–¡ Tested 100+ simultaneous requests
â–¡ Verified final state is correct
â–¡ Tested timeout/failure scenarios
```

---

## âš ï¸ ANTI-PATTERNS

### âŒ Don't: Trust Defaults
```typescript
// BAD: What's the default? Varies by database!
await db.transaction(async (tx) => {
  // Mysterious behavior
});
```

### âŒ Don't: Skip Concurrent Tests
```typescript
// BAD: "Works on my machine" with single request
it('should add like', async () => {
  const result = await addLike('video', 'ip');
  expect(result.added).toBe(true);
  // Never tested concurrent access!
});
```

### âœ… Do: Explicit + Tested
```typescript
// GOOD: Clear intent, proven correct
await tx.query('SET TRANSACTION ISOLATION LEVEL SERIALIZABLE');
// ... and 100-concurrent test passes
```

---

## ðŸ“‹ QUICK REFERENCE

```
TRANSACTION RULES:
â”œâ”€â”€ Always SET ISOLATION explicitly
â”œâ”€â”€ Add UNIQUE constraints for dedup
â”œâ”€â”€ Use FOR UPDATE for read-modify-write
â”œâ”€â”€ Use atomic UPDATE for counters
â””â”€â”€ Test with 100+ concurrent requests

ISOLATION SELECTION:
â”œâ”€â”€ Simple CRUD â†’ READ COMMITTED
â”œâ”€â”€ Multiple reads â†’ REPEATABLE READ
â”œâ”€â”€ Critical ops â†’ SERIALIZABLE
â””â”€â”€ When in doubt â†’ SERIALIZABLE
```

---

## âœ… VERIFICATION CHECKLIST

Before code is complete:

```
â–¡ Isolation level explicitly set in code
â–¡ Unique constraints added where needed
â–¡ Race condition patterns identified
â–¡ SELECT FOR UPDATE used appropriately
â–¡ Concurrent test written (100+ requests)
â–¡ Test verifies final state is correct
â–¡ Timeout handling implemented
â–¡ Transaction scope is minimal
```

---

*Explicit is better than implicit. Test concurrency or pay later.*
