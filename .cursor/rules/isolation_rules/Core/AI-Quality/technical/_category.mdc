---
description: Technical Rules Category - Transaction, MB Structure, Prompts
globs: technical/_category.mdc
alwaysApply: false
---

# TECHNICAL RULES (Rules #13-15)

> **Technical practices for BUILD, CREATIVE, and ARCHIVE modes. Focus: data safety, context organization, prompt quality.**

## ðŸ“‹ CATEGORY OVERVIEW

| Rule | Name | Key Practice | Apply When |
|------|------|--------------|------------|
| #13 | **Transaction** | Explicit isolation levels | Database operations |
| #14 | **MB Structure** | Hierarchical summaries | Context organization |
| #15 | **Prompts** | Structured prompt creation | Any AI interaction |

---

## 1ï¸âƒ£3ï¸âƒ£ TRANSACTION ISOLATION RULE (#13)

### One-Liner
> Explicitly specify transaction isolation level. Discuss race conditions upfront.

### Quick Application

```typescript
// âœ… GOOD: Explicit isolation level
async function addLike(videoId: string, ipAddress: string) {
  return await db.transaction(async (tx) => {
    // Explicitly set isolation
    await tx.query('SET TRANSACTION ISOLATION LEVEL SERIALIZABLE');
    
    // Check existing (protected from race)
    const existing = await tx.query(
      'SELECT * FROM likes WHERE video_id = $1 AND ip_address = $2',
      [videoId, ipAddress]
    );
    
    if (existing.rows.length > 0) {
      return { added: false };
    }
    
    // Insert with constraint protection
    await tx.query(
      'INSERT INTO likes (video_id, ip_address) VALUES ($1, $2)',
      [videoId, ipAddress]
    );
    
    return { added: true };
  });
}
```

### Isolation Levels Reference

| Level | Dirty Read | Non-Repeatable | Phantom | Use Case |
|-------|------------|----------------|---------|----------|
| READ UNCOMMITTED | âœ“ | âœ“ | âœ“ | Never |
| READ COMMITTED | âœ— | âœ“ | âœ“ | Default |
| REPEATABLE READ | âœ— | âœ— | âœ“ | Most cases |
| SERIALIZABLE | âœ— | âœ— | âœ— | Critical ops |

### Concurrency Test Template

```typescript
it('handles 100 concurrent operations', async () => {
  const promises = Array(100).fill(null)
    .map(() => storage.addLike('video1', '192.168.1.1'));
  await Promise.all(promises);
  
  const count = await storage.getLikeCount('video1');
  expect(count).toBe(1); // NOT 100!
});
```

---

## 1ï¸âƒ£4ï¸âƒ£ MEMORY BANK STRUCTURE RULE (#14)

### One-Liner
> Organize context hierarchically. Less detail for bigger scope.

### Quick Application

```
HIERARCHY PRINCIPLE:
â”œâ”€â”€ Full Project    â†’ Very high level (technologies, purpose)
â”œâ”€â”€ Module/Folder   â†’ Medium detail (interfaces, key functions)
â””â”€â”€ Specific File   â†’ High detail (algorithms, edge cases)

SAVE SUMMARIES:
Chat 1: Summarize /auth â†’ Save to Memory Bank as "auth-overview"
Chat 2: Summarize /auth/oauth â†’ Save as "oauth-details"
Chat 3: Reference saved summaries when coding
```

### Memory Bank Structure

```
memory-bank/
â”œâ”€â”€ tasks.md           â† Active task (most detail)
â”œâ”€â”€ activeContext.md   â† Current focus
â”œâ”€â”€ progress.md        â† Status tracking
â”œâ”€â”€ projectbrief.md    â† Project overview (high level)
â”œâ”€â”€ productContext.md  â† Product info
â”œâ”€â”€ systemPatterns.md  â† Patterns used
â”œâ”€â”€ techContext.md     â† Tech decisions
â”œâ”€â”€ creative/          â† Design decisions
â”œâ”€â”€ reflection/        â† Review learnings
â””â”€â”€ archive/           â† Completed tasks
```

### Benefits
- Clean context in main chat
- Reusable summaries
- Easy to update parts
- Token efficient

---

## 1ï¸âƒ£5ï¸âƒ£ PROMPT ENGINEERING RULE (#15)

### One-Liner
> Use structured prompts with context, expected results, DoD, and boundaries.

### Quick Application

```markdown
## GOOD PROMPT STRUCTURE

### Context
[Brief background OR reference to Memory Bank]

### Task
[Specific, focused task description]

### Expected Results
- Happy path: [concrete example]
- Edge cases: [list specific cases]

### Definition of Done
- [ ] Criterion 1
- [ ] Criterion 2

### Boundaries
- We DON'T: [explicit exclusions]

### Approach
[skeleton-first / TDD / iterative]
```

### Example Good Prompt

```markdown
**Context:** User authentication module (see Memory Bank: auth-overview)

**Task:** Implement validateToken() method

**Expected Results:**
- Valid token â†’ returns user object
- Expired token â†’ throws TokenExpiredError
- Invalid token â†’ throws InvalidTokenError

**DoD:**
- [ ] All 3 test cases pass
- [ ] Method < 30 lines
- [ ] Errors properly typed

**Boundaries:**
- NOT implementing token refresh (separate task)

**Approach:** TDD - write tests first
```

### Prompt Checklist
- [ ] Context sufficient (not too much, not too little)
- [ ] Expected results concrete (not vague)
- [ ] DoD explicit and testable
- [ ] Boundaries clear
- [ ] Prompt < 500 words

---

## ðŸŽ¯ WHEN TO APPLY

```mermaid
graph TD
    Start["Technical Task"] --> Q1{"Database<br>operation?"}
    Q1 -->|Yes| Apply13["Apply Rule #13:<br>Transaction"]
    Q1 -->|No| Q2{"Organizing<br>context?"}
    
    Apply13 --> Q2
    Q2 -->|Yes| Apply14["Apply Rule #14:<br>MB Structure"]
    Q2 -->|No| Q3{"Asking<br>AI?"}
    
    Apply14 --> Q3
    Q3 -->|Yes| Apply15["Apply Rule #15:<br>Structured Prompt"]
    Q3 -->|No| Done["Proceed"]
    Apply15 --> Done
```

---

## ðŸ“‚ DETAILED RULES

For comprehensive guidance:
- `transaction-rule.mdc` - Isolation level guide
- `mb-structure-rule.mdc` - Memory Bank organization
- `prompt-engineering-rule.mdc` - Prompt templates

---

*Technical rules prevent data corruption and improve AI output quality.*
